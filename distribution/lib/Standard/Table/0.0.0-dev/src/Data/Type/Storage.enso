from Standard.Base import all
import Standard.Base.Errors.Common.Index_Out_Of_Bounds
import Standard.Base.Errors.Illegal_State.Illegal_State

import Standard.Table.Data.Type.Value_Type.Value_Type
import Standard.Table.Data.Type.Value_Type.Bits
from Standard.Table.Errors import Inexact_Type_Coercion

polyglot java import org.enso.table.data.column.builder.object.Builder
polyglot java import org.enso.table.data.column.storage.type.Constants
polyglot java import org.enso.table.data.column.storage.type.StorageType
polyglot java import org.enso.table.data.column.storage.type.Integer as Storage_Integer
polyglot java import org.enso.table.data.column.storage.type.Float as Storage_Float
polyglot java import org.enso.table.data.column.storage.type.Boolean as Storage_Boolean
polyglot java import org.enso.table.data.column.storage.type.Text as Storage_Text
polyglot java import org.enso.table.data.column.storage.type.Date as Storage_Date
polyglot java import org.enso.table.data.column.storage.type.DateTime as Storage_DateTime
polyglot java import org.enso.table.data.column.storage.type.TimeOfDay as Storage_TimeOfDay
polyglot java import org.enso.table.data.column.storage.type.AnyObject as Storage_AnyObject

## PRIVATE
   Gets the value type represented by this Java Storage.
to_value_type : StorageType -> Value_Type
to_value_type storage_type = case storage_type of
    i : Storage_Integer -> case i.bits.toInteger of
        8 -> Value_Type.Byte
        b -> Value_Type.Integer (Bits.from_bits b)
    f : Storage_Float ->
        bits = Bits.from_bits f.bits.toInteger
        Value_Type.Float bits
    _ : Storage_Boolean -> Value_Type.Boolean
    s : Storage_Text ->
        variable = s.fixedLength.not
        size = if s.maxLength < 0 then Nothing else s.maxLength
        Value_Type.Char size variable
    _ : Storage_Date -> Value_Type.Date
    _ : Storage_DateTime -> Value_Type.Date_Time with_timezone=True
    _ : Storage_TimeOfDay -> Value_Type.Time
    _ : Storage_AnyObject -> Value_Type.Mixed

## PRIVATE
closest_storage_type value_type = case value_type of
    # TODO we will want builders and storages with bounds checking, but for now we approximate
    Value_Type.Byte -> Constants.INTEGER_64
    Value_Type.Integer _ -> Constants.INTEGER_64
    Value_Type.Float _ -> Constants.FLOAT_64
    Value_Type.Boolean -> Constants.BOOLEAN
    Value_Type.Char _ _ -> Constants.STRING
    Value_Type.Date -> Constants.DATE
    # We currently will not support storing dates without timezones in in-memory mode.
    Value_Type.Date_Time _ -> Constants.DATE_TIME
    Value_Type.Time -> Constants.TIME_OF_DAY
    Value_Type.Mixed -> Constants.ANY_OBJECT

## PRIVATE
from_value_type : Value_Type -> Problem_Behavior -> StorageType
from_value_type value_type on_problems =
    approximate_storage = closest_storage_type value_type
    approximated_value_type = to_value_type approximate_storage
    problems = if approximated_value_type == value_type then [] else
        [Inexact_Type_Coercion.Warning value_type approximated_value_type]
    on_problems.attach_problems_before problems approximate_storage

## PRIVATE
   Creates a column storage builder for the given storage type.
make_builder : StorageType -> Integer -> Builder
make_builder storage initial_size=64 =
    Builder.getForType storage initial_size
