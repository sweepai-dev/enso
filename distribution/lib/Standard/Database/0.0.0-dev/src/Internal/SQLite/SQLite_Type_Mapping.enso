from Standard.Base import all
import Standard.Base.Error.Illegal_Argument.Illegal_Argument

import Standard.Table.Data.Type.Value_Type.Value_Type
import Standard.Table.Data.Type.Value_Type.Bits
from Standard.Table.Errors import Inexact_Type_Coercion

import project.Data.SQL_Type.SQL_Type

polyglot java import java.sql.Types

## PRIVATE
   Mapping from Value_Type to SQLite is done by finding the closest matching
   type corresponding to one of the 4 supported affinities: INTEGER, REAL,
   NUMERIC, TEXT, BLOB. Thus many value types will end up being approximated by
   a close but inexact type. Apart from that, a fourth artificial affinity is
   introduced: BOOLEAN. Normally, SQLite does not have a dedicated boolean type
   and uses INTEGER instead. However, it is useful for our users to distinguish
   the boolean columns. We do this by manually overriding the type of columns
   detected as boolean or returned from our boolean operations. The JDBC
   automatically handles translating between the underlying INTEGER storage and
   Java Booleans, so it is all seamless - only our type logic needs to be aware
   that it cannot rely on the JDBC metadata as the type reported for boolean
   operations will be INTEGER - so we need to carefully ensure there is the
   override.

   While the JDBC driver tries to approximate more precise types based on the
   type name, these approximations are not fully true as the underlying SQLite
   storage is still only one of the supported affinities. So to avoid suggesting
   to the user that the database can do stuff which it cannot (like storing
   integers truncating them at 32-bits or storing fixed-length text) we
   approximate the supported types by data types that correspond to what can
   actually be stored in the given column to match its affinity. While SQLite
   allows to store any data in a column, we restrict the data to only what can
   match the column's affinity to be aligned with our other backends.

   We map the BLOB affinity to our Mixed type to allow for Mixed type columns.
   One can still store binary data in such a column.
   TODO [RW] do we want that or do we want to map to binary? but then we'd have
   to disallow Mixed as it's impossible to distinguish, at least without
   additional machinery

   See `JDBC3ResultSet::getColumnType` method in the `org.xerial.sqlite-jdbc`
   module for the logic JDBC is using to map the SQLite types.
type SQLite_Type_Mapping
    ## PRIVATE
    value_type_to_sql : Value_Type -> Problem_Behavior -> SQL_Type
    value_type_to_sql value_type on_problems =
        result = case value_type of
            Value_Type.Boolean -> SQLite_Types.boolean
            Value_Type.Byte -> SQLite_Types.integer
            Value_Type.Integer _ -> SQLite_Types.integer
            Value_Type.Float _ -> SQLite_Types.real
            Value_Type.Decimal _ _ -> SQLite_Types.numeric
            Value_Type.Char _ _ -> SQLite_Types.text
            Value_Type.Time -> SQLite_Types.blob
            Value_Type.Date -> SQLite_Types.blob
            Value_Type.Date_Time _ -> SQLite_Types.blob
            Value_Type.Binary _ _ -> SQLite_Types.blob
            Value_Type.Mixed -> SQLite_Types.blob
            Value_Type.Unsupported_Data_Type type_name underlying_type ->
                underlying_type.if_nothing <|
                    Error.throw <|
                        Illegal_Argument.Error <|
                            "An unsupported SQL type ["+type_name.to_text+"] cannot be converted into an SQL type because it did not contain the SQL metadata needed to reconstruct it."
        approximated_value_type = SQLite_Type_Mapping.sql_type_to_value_type result
        problems = if approximated_value_type == value_type then [] else [Inexact_Type_Coercion.Warning value_type approximated_value_type]
        on_problems.attach_problems_before problems result

    ## PRIVATE
    sql_type_to_value_type : SQL_Type -> Value_Type
    sql_type_to_value_type sql_type =
        on_not_found =
            Value_Type.Unsupported_Data_Type sql_type.name sql_type
        simple_types_map.get sql_type.typeid on_not_found

    ## PRIVATE
       The SQLite type mapping takes special measures to keep boolean columns
       boolean even if the Database will say that they are numeric.

       To do so, any operation that returns booleans will override its return
       type to boolean, and operations that return the same type as inputs will
       also ensure to override to the boolean type if the input was boolean. In
       particular, if the operations accept multiple arguments, they will
       override the return type to boolean if all the input arguments had
       boolean type.
    infer_return_type : Connection -> Context -> Text -> Vector -> Expression -> SQL_Type_Reference
    infer_return_type connection context op_name arguments expression =
        return_boolean =
            SQL_Type_Reference.from_constant (SQLite_Types.boolean)
        infer_default_type =
            SQL_Type_Reference.new connection context expression

        find_type arg = case arg
        always_boolean_ops = ["==", "!=", "equals_ignore_case", ">=", "<=", "<", ">", "BETWEEN", "AND", "OR", "IS_NULL", "IS_NAN", "IS_EMPTY", "LIKE", "IS_IN"]
        preserve_input_type_ops = ["ROW_MAX", "ROW_MIN", "MAX", "MIN"]
        case always_boolean_ops.contains op_name of
            True -> return_boolean
            False -> case preserve_input_type_ops.contains op_name of
                True ->
                    inputs_types = arguments.map find_type
                    if inputs_types.all (== Value_Type.Boolean) then return_boolean else
                        infer_default_type
                False -> infer_default_type

## The types that SQLite JDBC driver will report are: BOOLEAN, TINYINT,
   SMALLINT, BIGINT, INTEGER, DECIMAL, DOUBLE, REAL, FLOAT, NUMERIC, DATE,
   TIMESTAMP, CHAR, VARCHAR, BINARY, BLOB, CLOB.

   We map the types to how they are actually stored, with the exception of
   boolean which is mapped as boolean type as explained above.

   For types like dates - we map them to unsupported type, because date
   operations in SQLite are currently not supported due to their weird storage.
simple_types_map = Map.from_vector <|
    ints = [Types.TINYINT, Types.SMALLINT, Types.BIGINT, Types.INTEGER] . map x-> [x, Value_Type.Integer Bits.Bits_64]
    floats = [Types.DOUBLE, Types.REAL, Types.FLOAT] . map x-> [x, Value_Type.Float Bits.Bits_64]
    numerics = [Types.DECIMAL, Types.NUMERIC] . map x-> [x, Value_Type.Decimal]
    strings = [Types.CHAR, Types.VARCHAR] . map x-> [x, Value_Type.Char size=Nothing variable=True]
    blobs = [Types.BINARY, Types.BLOB, Types.CLOB] . map x-> [x, Value_Type.Mixed]
    special_types = [[Types.BOOLEAN, Value_Type.Boolean]]
    ints + floats + numerics + strings + blobs + special_types

type SQLite_Types
    ## PRIVATE
    text = SQL_Type.Value Types.VARCHAR "TEXT"

    ## PRIVATE
    numeric = SQL_Type.Value Types.NUMERIC "NUMERIC"

    ## PRIVATE
    integer = SQL_Type.Value Types.INTEGER "INTEGER"

    ## PRIVATE
    real = SQL_Type.Value Types.REAL "REAL"

    ## PRIVATE
    blob = SQL_Type.Value Types.BLOB "BLOB"

    ## PRIVATE
       The artificial 6th affinity that is used to distinguish boolean columns.
    boolean = SQL_Type.Value Types.BOOLEAN "BOOLEAN"
