from Standard.Base import all
import Standard.Base.Error.Illegal_Argument.Illegal_Argument

import Standard.Table.Data.Type.Value_Type.Value_Type
import Standard.Table.Data.Type.Value_Type.Bits
from Standard.Table.Errors import Inexact_Type_Coercion

import project.Data.SQL_Type.SQL_Type

polyglot java import java.sql.Types

# TODO [RW] likely we could make this into a Base_SQL_Type_Mapping that can be reused across SQLite and Postgres, with adaptations if needed.

## PRIVATE
   Mapping from Value_Type to SQLite is done by finding the closest matching
   type corresponding to one of the 4 supported affinities: INTEGER, REAL,
   NUMERIC, TEXT, BLOB. Thus many value types will end up being approximated by
   a close but inexact type. Apart from that, a fourth artificial affinity is
   introduced: BOOLEAN. Normally, SQLite does not have a dedicated boolean type
   and uses INTEGER instead. However, it is useful for our users to distinguish
   the boolean columns. We do this by manually overriding the type of columns
   detected as boolean or returned from our boolean operations. The JDBC
   automatically handles translating between the underlying INTEGER storage and
   Java Booleans, so it is all seamless - only our type logic needs to be aware
   that it cannot rely on the JDBC metadata as the type reported for boolean
   operations will be INTEGER - so we need to carefully ensure there is the
   override.

   TODO update description - JDBC has more flexibility but its mostly fake, so maybe we map to what is truly there? probably yes
   The types are mapped according to the rules set in the JDBC SQLite driver
   which adds support for a few more types than raw SQLite - for example even
   though a BOOLEAN column will be stored as numbers, the JDBC driver is able to
   detect the BOOLEAN column type name and treat its contents as boolean values.
   This is useful, as it allows us to use a bit more precise types than what
   pure SQLite would allow. If the DB author declared a column as BOOLEAN, we
   probably indeed want to view it as booleans values in Enso, and this
   mechanism gives us this ability.

   The exact rules can be found in the `JDBC3ResultSet::getColumnType` method in
   the `org.xerial.sqlite-jdbc` module.
type SQLite_Type_Mapping
    ## PRIVATE
    value_type_to_sql : Value_Type -> Problem_Behavior -> SQL_Type
    value_type_to_sql value_type on_problems =
        result = case value_type of
            Value_Type.Boolean -> SQLite_Types.boolean
            Value_Type.Byte -> SQLite_Types.integer
            Value_Type.Integer _ -> SQLite_Types.integer
            Value_Type.Float _ -> SQLite_Types.real
            Value_Type.Decimal _ _ -> SQLite_Types.numeric
            Value_Type.Char _ _ -> SQLite_Types.text
            Value_Type.Time -> SQLite_Types.blob
            Value_Type.Date -> SQLite_Types.blob
            Value_Type.Date_Time _ -> SQLite_Types.blob
            Value_Type.Binary _ _ -> SQLite_Types.blob
            Value_Type.Mixed -> SQLite_Types.blob
            Value_Type.Unsupported_Data_Type type_name underlying_type ->
                underlying_type.if_nothing <|
                    Error.throw <|
                        Illegal_Argument.Error <|
                            "An unsupported SQL type ["+type_name.to_text+"] cannot be converted into an SQL type because it did not contain the SQL metadata needed to reconstruct it."
        approximated_value_type = SQLite_Type_Mapping.sql_type_to_value_type result
        problems = if approximated_value_type == value_type then [] else [Inexact_Type_Coercion.Warning value_type approximated_value_type]
        on_problems.attach_problems_before problems result

    ## PRIVATE
    sql_type_to_value_type : SQL_Type -> Value_Type
    sql_type_to_value_type sql_type =
        on_not_found =
            Value_Type.Unsupported_Data_Type sql_type.name sql_type
        simple_types_map.get sql_type.typeid on_not_found

## The types that SQLite JDBC driver will report are:
   - BOOLEAN
   - TINYINT
   - SMALLINT
   - BIGINT
   - INTEGER
   - DECIMAL
   - DOUBLE
   - REAL
   - FLOAT
   - NUMERIC
   - DATE
   - TIMESTAMP
   - CHAR
   - VARCHAR
   - BINARY
   - BLOB
   - CLOB

   We map the types to how they are actually stored, with the exception of
   boolean which is mapped as boolean type as explained above.

   For types like dates - we map them to unsupported type, because date
   operations in SQLite are currently not supported due to their weird storage.
simple_types_map = Map.from_vector <|
    ints = [Types.TINYINT, Types.SMALLINT, Types.BIGINT, Types.INTEGER] . map x-> [x, Value_Type.Integer Bits.Bits_64]
    floats = [Types.DOUBLE, Types.REAL, Types.FLOAT] . map x-> [x, Value_Type.Float Bits.Bits_64]
    numerics = [Types.DECIMAL, Types.NUMERIC] . map x-> [x, Value_Type.Decimal]
    strings = [Types.CHAR, Types.VARCHAR] . map x-> [x, Value_Type.Char size=Nothing variable=True]
    blobs = [Types.BINARY, Types.BLOB, Types.CLOB] . map x-> [x, Value_Type.Binary size=Nothing variable=True]
    special_types = [[Types.BOOLEAN, Value_Type.Boolean]]
    ints + floats + numerics + strings + blobs + special_types

type SQLite_Types
    ## PRIVATE
    text = SQL_Type.Value Types.VARCHAR "TEXT"

    ## PRIVATE
    numeric = SQL_Type.Value Types.NUMERIC "NUMERIC"

    ## PRIVATE
    integer = SQL_Type.Value Types.INTEGER "INTEGER"

    ## PRIVATE
    real = SQL_Type.Value Types.REAL "REAL"

    ## PRIVATE
    blob = SQL_Type.Value Types.BLOB "BLOB"

    ## PRIVATE
       The artificial 6th affinity that is used to distinguish boolean columns.
    boolean = SQL_Type.Value Types.BOOLEAN "BOOLEAN"
