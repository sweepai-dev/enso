from Standard.Base import all
import Standard.Base.Error.Illegal_Argument.Illegal_Argument

import Standard.Table.Data.Type.Value_Type.Value_Type

polyglot java import java.sql.Types

# TODO [RW] likely we could make this into a Base_SQL_Type_Mapping that can be reused across SQLite and Postgres, with adaptations if needed.

## PRIVATE
   The types are mapped according to the rules set in the JDBC SQLite driver
   which adds support for a few more types than raw SQLite - for example even
   though a BOOLEAN column will be stored as numbers, the JDBC driver is able to
   detect the BOOLEAN column type name and treat its contents as boolean values.
   This is useful, as it allows us to use a bit more precise types than what
   pure SQLite would allow. If the DB author declared a column as BOOLEAN, we
   probably indeed want to view it as booleans values in Enso, and this
   mechanism gives us this ability.

   The exact rules can be found in the `JDBC3ResultSet::getColumnType` method in
   the `org.xerial.sqlite-jdbc` module.
type SQLite_Type_Mapping
    ## PRIVATE
    value_type_to_sql : Value_Type -> Problem_Behavior -> SQL_Type
    value_type_to_sql value_type on_problems = case value_type of
        Value_Type.Boolean -> boolean
        # TODO should we allow these numeric types that are faked by SQLite or coerce all of them to INTEGER?
        Value_Type.Byte -> SQL_Type.Value Types.TINYINT "TINYINT"
        Value_Type.Integer Bits.Bits_16 -> SQL_Type.Value Types.SMALLINT "SMALLINT"
        Value_Type.Integer Bits.Bits_32 -> SQL_Type.Value Types.INTEGER "INTEGER"
        Value_Type.Integer Bits.Bits_64 -> SQL_Type.Value Types.BIGINT "BIGINT"
        Value_Type.Float Bits.Bits_32 -> SQL_Type.Value Types.REAL "REAL"
        Value_Type.Float Bits.Bits_64 -> SQL_Type.Value Types.DOUBLE "DOUBLE"
        Value_Type.Decimal precision scale -> numeric precision scale
        Value_Type.Char size variable ->
            if variable then varchar size else char size
        Value_Type.Time ->
        Value_Type.Date ->
        Value_Type.Date_Time with_timezone ->
            ???
        Value_Type.Binary size variable -> binary variable size
        Value_Type.Mixed -> binary variable=True size=Nothing
        Value_Type.Unsupported_Data_Type type_name underlying_type ->
            underlying_type.if_nothing <|
                Error.throw <|
                    Illegal_Argument.Error <|
                        "An unsupported SQL type ["+type_name.to_text+"] cannot be converted into an SQL type because it did not contain the SQL metadata needed to reconstruct it."

    ## PRIVATE
    sql_type_to_value_type : SQL_Type -> Value_Type
    sql_type_to_value_type sql_type =
        handle_not_found =
            Error.throw <| Illegal_Argument.Error <|
                "The SQL type ["+sql_type.to_text+"] is not recognized as an SQLite compatible type."
        simple_type = simple_types_map.get sql_type.typeid Nothing
        simple_type.if_nothing <|
            ## If we didn't match any of the types from the simple mapping, we
               continue with the more complex mappings that take stuff like
               precision into account.
            builder = complex_types_map.get sql_type.typeid handle_not_found
            builder sql_type

## The types that SQLite JDBC driver will report are:
   - BOOLEAN
   - TINYINT
   - SMALLINT
   - BIGINT
   - INTEGER
   - DECIMAL
   - DOUBLE
   - REAL
   - FLOAT
   - NUMERIC
   - DATE
   - TIMESTAMP
   - CHAR
   - VARCHAR
   - BINARY
   - BLOB
   - CLOB

   This maps the types that are mapped to a constant value type.
   For some types, a more involved logic is needed.
simple_types_map = Map.from_vector <|
    ints = [[Types.TINYINT, Value_Type.Byte], [Types.SMALLINT, Value_Type.Integer Bits.Bits_16], [Types.BIGINT, Value_Type.Integer Bits.Bits_64], [Types.INTEGER, Value_Type.Integer Bits.Bits_64]]
    # In SQLite all reals are 64-bit floats. For other engines we may need to distinguish between these.
    floats = [[Types.DOUBLE, Value_Type.Float Bits.Bits_64], [Types.REAL, Value_Type.Float Bits.Bits_64], [Types.FLOAT, Value_Type.Float Bits.Bits_64]]
    other = [[Types.BOOLEAN, Value_Type.Boolean], [Types.TIMESTAMP, Value_Type.Date_Time with_timezone=False], [Types.DATE, Value_Type.Date]]
    ints + other

complex_types_map = Map.from_vector <|
    make_decimal sql_type =
        Value_Type.Decimal sql_type.precision sql_type.scale
    make_varchar sql_type =
        Value_Type.Char size=sql_type.precision variable=True
    make_char sql_type =
        Value_Type.Char size=sql_type.precision variable=False
    make_binary sql_type variable =
        Value_Type.Binary size=sql_type.precision variable=variable
    numerics = [[Types.DECIMAL, make_decimal], [Types.NUMERIC, make_decimal]]
    # TODO [RW] should CLOB be text or not? should we have a separate type for it? otherwise we cannot round-trip (CLOB -> Char -> VARCHAR != CLOB)
    strings = [[Types.VARCHAR, make_varchar], [Types.CHAR, make_char], [Types.CLOB, make_varchar]]
    binaries = [[Types.BINARY, make_binary False], [Types.BLOB, make_binary True]]
    numerics + strings + binaries

numeric precision scale = SQL_Type.Value Types.NUMERIC "NUMERIC" precision=precision scale=scale
varchar size = SQL_Type.Value Types.VARCHAR "VARCHAR" precision=size
boolean = SQL_Type.Value Types.BOOLEAN "BOOLEAN"
char size = SQL_Type.Value Types.CHAR "CHAR" precision=size
binary variable size =
    if variable then SQL_Type.Value Types.BLOB "BLOB" precision=size else
        SQL_Type.Value Types.BINARY "BINARY" precision=size
