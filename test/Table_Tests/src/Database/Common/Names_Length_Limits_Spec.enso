from Standard.Base import all

from Standard.Table import Table

from Standard.Database import all
from Standard.Database.Errors import all

from Standard.Test import Test, Test_Suite, Problems
import Standard.Test.Extensions

import project.Util
import project.Database.Helpers.Name_Generator

spec prefix connection =
    Test.group prefix+" Support for Long Column/Table names" <|
        has_maximum_table_name_length = connection.dialect.max_table_name_length
        has_maximum_column_name_length = connection.dialect.max_column_name_length
        big_name_length = 10000

        if has_maximum_table_name_length.not then
            Test.specify "should allow to create tables with very long names" <|
                name = "a" * big_name_length
                src = Table.new [["X", [1, 2, 3]]]
                dest = src.select_into_database_table connection name temporary=True
                Problems.assume_no_problems dest

                dest_fetched = connection.query name
                dest_fetched.at "X" . to_vector . should_equal [1, 2, 3]

        if has_maximum_table_name_length then
            Test.specify "should raise an error when creating a table with a column name that is too long" <|
                name = "a" *
                src = Table.new [["X", [1, 2, 3]]]
                r = src.select_into_database_table connection name temporary=True
                r.should_fail_with Name_Too_Long
                r.catch.entity_kind . should_equal "table"
                r.catch.name . should_equal name
                c.catch.to_display_text . should_contain "The table name"
                c.catch.to_display_text . should_contain "is too long"

            Test.specify "should ensure length is measured in code units, even if grapheme length is lower" <|
                # TODO test with emojis
                Error.throw "TODO"

        Test.specify "should be fine joining tables with long names" <|
            ## If we know the maximum length, we choose a length that will be
               just short enough to fit in the limit, but long enough that after
               concatenating two of such names, the result will exceed the limit.
               If we don't know the limit, we just choose a very long name.
            name_length = case connection.dialect.max_table_name_length of
                Nothing -> 5000
                max : Integer -> max

            name_a = ("x" * (name_length - 1)) + "a"
            name_b = ("x" * (name_length - 1)) + "b"
            Error.throw "TODO"

        if has_maximum_column_name_length.not then
            Test.specify "should allow to create very long column names" <|
                src = Table.new [["X", [1, 2, 3]]]
                db_table = src.select_into_database_table connection (Name_Generator.random_name "long-column-names") temporary=True
                c = db_table.at "X"
                long_name = "a" * big_name_length
                c2 = c.rename long_name
                Problems.assume_no_problems c2
                v = c2.to_vector
                v . should_equal [1, 2, 3]
                Problems.assume_no_problems v

            Test.specify "should allow to upload tables with very long column names" <|
                name_a = "x" * big_name_length + "a"
                name_b = "x" * big_name_length + "b"
                src = Table.new [[name_a, [1, 2, 3]], [name_b, [4, 5, 6]]]
                db_table = src.select_into_database_table connection (Name_Generator.random_name "long-column-names") temporary=True
                Problems.assume_no_problems db_table
                db_table.at name_a . to_vector . should_equal [1, 2, 3]
                db_table.at name_b . to_vector . should_equal [4, 5, 6]

        if has_maximum_column_name_length then
            max_column_name_length = connection.dialect.max_column_name_length
            Test.specify "should raise an error when renaming a column to a name that is too long" <|
                src = Table.new [["X", [1, 2, 3]]]
                db_table = src.select_into_database_table connection (Name_Generator.random_name "long-column-names") temporary=True
                c = db_table.at "X"
                long_name = "a" * (max_column_name_length + 1)
                c2 = c.rename long_name
                c2.should_fail_with Name_Too_Long
                c2.catch.entity_kind . should_equal "column"
                c2.catch.name . should_equal long_name
                c2.catch.to_display_text . should_contain "The column name"
                c2.catch.to_display_text . should_contain "is too long"

            Test.specify "should truncate column names in upload when they are too long and issue a warning" <|
                name_a = "a" * (max_column_name_length + 1)
                name_a = "b" * (max_column_name_length + 1)
                src = Table.new [[name_a, [1, 2, 3]], [name_b, [4, 5, 6]]]
                db_table = src.select_into_database_table connection (Name_Generator.random_name "long-column-names") temporary=True
                w = Problems.expect_only_warning Truncated_Column_Names db_table
                w.original_names . should_equal [name_a, name_b]
                w.truncated_names . should_equal ["a" * max_column_name_length, "b" * max_column_name_length]

                db_table.at ("a" * max_column_name_length) . to_vector . should_equal [1, 2, 3]
                db_table.at ("b" * max_column_name_length) . to_vector . should_equal [4, 5, 6]

            Test.specify "should truncate column names in upload when they are too long, rename them if needed and issue a warning" <|
                name_a = "x" * (max_column_name_length + 1) + "A"
                name_a = "x" * (max_column_name_length + 1) + "B"
                src = Table.new [[name_a, [1, 2, 3]], [name_b, [4, 5, 6]], ["C", [7, 8, 9]]]
                db_table = src.select_into_database_table connection (Name_Generator.random_name "long-column-names") temporary=True
                w = Problems.expect_only_warning Truncated_Column_Names db_table
                w.original_names . should_equal [name_a, name_b]

                db_table.at name_a . should_fail_with No_Such_Column
                db_table.at name_b . should_fail_with No_Such_Column
                db_table.at "C" . to_vector . should_equal [7, 8, 9]

                db_table.column_names . should_equal (w.truncated_names+["C"])
                db_table.at (w.truncated_names.at 0) . to_vector . should_equal [1, 2, 3]
                db_table.at (w.truncated_names.at 1) . to_vector . should_equal [4, 5, 6]

                # This should work even if there is a lot of columns like this (i.e. a number that we use to make them unique is more than 1 digit)
                src2 = Table.new (0.up_to 15 . map i-> ["x" * (max_column_name_length + 10) + i.to_string, [100+i, 200+i, 300+i]])
                db_table2 = src2.select_into_database_table connection (Name_Generator.random_name "long-column-names") temporary=True
                w2 = Problems.expect_only_warning Truncated_Column_Names db_table2
                w2.original_names . should_equal src2.column_names
                db_table2.column_names . should_equal w2.truncated_names
                0.up_to 15 . each i->
                    db_table2.at (w2.truncated_names.at i) . to_vector . should_equal [100+i, 200+i, 300+i]

            Test.specify "should ensure length is measured in code units, even if grapheme length is lower" <|
                # TODO test with emojis: upload, rename, operation
                Error.throw "TODO"

            Test.specify "should truncate the column name if the resulting operation-generated name is too long, without warnings" <|
                long_name = "a" * max_column_name_length
                src = Table.new [[long_name, [1, 2, 3]]]
                db_table = src.select_into_database_table connection (Name_Generator.random_name "long-column-names") temporary=True
                c0 = db_table.at long_name

                c1 = c0 + 10
                c1.to_vector . should_equal [11, 12, 13]
                # truncated
                c1.name . should_equal long_name

                c2 = c0.ceil
                c2.to_vector . should_equal [1, 2, 3]
                # truncated
                c2.name . should_equal (("ceil(" + long_name).take max_column_name_length)

                c3 = c1.cast Value_Type.Char . starts_with "1"
                c3.to_vector . should_equal [True, False, False]
                c3.name.length . should_equal max_column_name_length
                c3.name . should_contain "starts_with"

            Test.specify "should truncate the names and deduplicate them when the resulting names would be too long in aggregate" <|
                # TODO scenario 1 - automatic names
                # TODO scenario 2 - user-provided names
                Error.throw "TODO"

            Test.specify "should fail a cross-tab if the column names are too long" <|
                # TODO cross tab is currently not implemented, so nothing to test here, but this test ensures that we won't forget to update it once we implement it
                name_a = "x" * (max_column_name_length + 1) + "A"
                name_b = "x" * (max_column_name_length + 1) + "B"
                src = Table.new [["X", [name_a, name_b, name_a]], ["Y", [4, 5, 6]]]
                db_table = src.select_into_database_table connection (Name_Generator.random_name "cross-tab") temporary=True
                db_table.cross_tab name_column="X" . should_fail_with Unsupported_Database_Operation

            Test.specify "should fail if column names provided in transpose" <|
                # TODO transpose is currently not implemented, so nothing to test here, but this test ensures that we won't forget to update it once we implement it
                name_a = "x" * (max_column_name_length + 1) + "A"
                src = Table.new [["X", [name_a, name_b, name_a]], ["Y", [4, 5, 6]]]
                db_table = src.select_into_database_table connection (Name_Generator.random_name "cross-tab") temporary=True
                db_table.transpose attribute_column_name=name_a . should_fail_with Unsupported_Database_Operation
                db_table.transpose value_column_name=name_a . should_fail_with Unsupported_Database_Operation
