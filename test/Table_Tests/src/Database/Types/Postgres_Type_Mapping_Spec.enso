from Standard.Base import all

import Standard.Table.Data.Type.Value_Type.Value_Type
import Standard.Table.Data.Type.Value_Type.Bits

from Standard.Database import SQL_Query

from Standard.Test import Problems, Test, Test_Suite
import Standard.Test.Extensions

import project.Database.Helpers.Name_Generator
from project.Database.Postgres_Spec import test_with_connection

spec connection db_name =
    _ = db_name

    make_table prefix columns =
        name = Name_Generator.random_name prefix
        column_exprs = columns.map col_def->
            col_def.first + " " + col_def.second
        stmt = 'CREATE TEMPORARY TABLE "'+name+'" ('+(column_exprs.join ', ')+');'
        Problems.assume_no_problems <| connection.execute_update stmt
        connection.query (SQL_Query.Table_Name name)

    Test.group "[PostgreSQL] Type Mapping" <|
        Test.specify "numeric" <|
            t = make_table "ints" [["a", "smallint"], ["b", "int2"], ["c", "int"], ["d", "integer"], ["e", "int4"], ["f", "bigint"], ["g", "int8"]]
            t.info.print
            t.at "a" . value_type . should_equal (Value_Type.Integer Bits.Bits_16)
            t.at "b" . value_type . should_equal (Value_Type.Integer Bits.Bits_16)
            t.at "c" . value_type . should_equal (Value_Type.Integer Bits.Bits_32)
            t.at "d" . value_type . should_equal (Value_Type.Integer Bits.Bits_32)
            t.at "e" . value_type . should_equal (Value_Type.Integer Bits.Bits_32)
            t.at "f" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)
            t.at "g" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)

            t2 = make_table "floats" [["a", "real"], ["b", "float4"], ["c", "double precision"], ["d", "float8"]]
            t2.info.print
            t2.at "a" . value_type . should_equal (Value_Type.Float Bits.Bits_32)
            t2.at "b" . value_type . should_equal (Value_Type.Float Bits.Bits_32)
            t2.at "c" . value_type . should_equal (Value_Type.Float Bits.Bits_64)
            t2.at "d" . value_type . should_equal (Value_Type.Float Bits.Bits_64)

            t3 = make_table "decimals" [["a", "decimal"], ["b", "numeric"], ["c", "decimal(10, 2)"], ["d", "numeric(20, -2)"], ["e", "decimal(10)"], ["f", "numeric(20)"]]
            t3.info.print
            t3.at "a" . value_type . should_equal Value_Type.Decimal
            t3.at "b" . value_type . should_equal Value_Type.Decimal
            t3.at "c" . value_type . should_equal (Value_Type.Decimal precision=10 scale=2)
            t3.at "d" . value_type . should_equal (Value_Type.Decimal precision=20 scale=(-2))
            t3.at "e" . value_type . should_equal (Value_Type.Decimal precision=10)
            t3.at "f" . value_type . should_equal (Value_Type.Decimal precision=20)

        Test.specify "text" <|
            t = make_table "texts" [["a", "char(10)"], ["b", "varchar"], ["c", "varchar(20)"], ["d", "text"]]
            t.info.print
            t.at "a" . value_type . should_equal (Value_Type.Char size=10 variable=False)
            t.at "b" . value_type . should_equal (Value_Type.Char size=Nothing variable=True)
            t.at "c" . value_type . should_equal (Value_Type.Char size=20 variable=True)
            t.at "d" . value_type . should_equal (Value_Type.Char size=Nothing variable=True)

        Test.specify "binary" <|
            t = make_table "binaries" [["a", "bit(1)"], ["b", "bit varying"], ["c", "bit varying(10)"], ["d", "bytea"]]
            t.info.print
            t.at "a" . value_type . should_equal (Value_Type.Binary size=1 variable=False)
            t.at "b" . value_type . should_equal (Value_Type.Binary size=Nothing variable=True)
            t.at "c" . value_type . should_equal (Value_Type.Binary size=10 variable=True)
            t.at "d" . value_type . should_equal (Value_Type.Binary size=Nothing variable=True)

        Test.specify "datetime" <|
            t = make_table "dates" [["a", "date"]]
            t.info.print
            t.at "a" . value_type . should_equal Value_Type.Date

            t2 = make_table "times" [["a", "time"], ["b", "timetz"], ["c", "time without time zone"], ["d", "time with time zone"]]
            t2.info.print
            t2.at "a" . value_type . should_equal Value_Type.Time_Of_Day
            t2.at "b" . value_type . should_equal Value_Type.Time_Of_Day
            t2.at "c" . value_type . should_equal Value_Type.Time_Of_Day
            t2.at "d" . value_type . should_equal Value_Type.Time_Of_Day

            t3 = make_table "timestamps" [["a", "timestamp"], ["b", "timestamptz"], ["c", "timestamp without time zone"], ["d", "timestamp with time zone"]]
            t3.info.print
            t3.at "a" . value_type . should_equal (Value_Type.DateTime with_timezone=False)
            t3.at "b" . value_type . should_equal (Value_Type.DateTime with_timezone=True)
            t3.at "c" . value_type . should_equal (Value_Type.DateTime with_timezone=False)
            t3.at "d" . value_type . should_equal (Value_Type.DateTime with_timezone=True)

        Test.specify "boolean" <|
            t = make_table "bools" [["a", "boolean"], ["b", "bool"]]
            t.info.print
            t.at "a" . value_type . should_equal Value_Type.Boolean
            t.at "b" . value_type . should_equal Value_Type.Boolean

        Test.specify "should correctly handle types through operations" <|
            t = make_table "foo" [["a", "int"], ["b", "text"], ["c", "boolean"], ["d", "double precision"]]

            t.compute 'starts_with([b], "1")' . value_type . should_equal Value_Type.Boolean
            t.compute '[a] * [d]' . value_type . should_equal Value_Type.Float Bits.Bits_64
            t.compute '[a] + 100' . value_type . should_equal Value_Type.Integer Bits.Bits_32
            t.compute '[a] + 100.0' . value_type . should_equal Value_Type.Float Bits.Bits_64
            t.compute '[c] || not [c]' . value_type . should_equal Value_Type.Boolean
            t.compute '[b] + "_suf"' . value_type . should_equal Value_Type.Char

            # TODO
            t2 = t.aggregate [Aggregate_Column.Group_By "b", Aggregate_Column.Sum "a"]
            t2.info.print

            # TODO curious
            t2 = make_table "foo2" [["a", "char(5)"], ["b", "char(8)"]]
            IO.println <|
                "char(5)+char(8) = " + (t2.compute '[a] + [b]' . value_type)

main = Test_Suite.run_main (test_with_connection spec)
